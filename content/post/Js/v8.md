---
title: Javascript's v8
date: 2019-03-25
tags: [""]
categories: ["Javascript"]
description: Node的一个runtime。
img: https://dn-cnode.qbox.me/FgKu20kvFqHrkgpjbQxXkV1DmrG1
toc: true
draft: false
---


# V8内存管理机制

## 一、内存模型  
![V8内存](/images/javascript/v8内存结构图.png)  

>堆外内存：不通过V8分配，也不受管理，Buffer对象数据存放于此除堆外内存外，其余由V8管理

>栈（Stack）的分配与回收非常直接，当程序离开某作用域后，其栈指针下移（回退），整个作用域的局部变量都会出栈，内存收回。

>最复杂的部分是堆（Heap）的管理，V8使用垃圾回收机制进行堆的内存管理，也是开发中可能造成内存泄漏的部分

>通过 `process.memoryUsage()` 查看内存。`rss` 是Resident Set Size的缩写，为常驻内存的总大小，`heapTotal` 是V8为堆分配的总大小，`heapUsed `是已使用的堆大小。可以看到，rss是大于heapTotal的，因为rss包括且不限于堆。

---
## 二、堆内存限制
>默认情况，V8分配内存不超过`1.4G(x64 1.4G,x86 0.7G)`,如果读取大于 `1.4G` 的文件是无法实现的，但可以通过Node命令更改V8为堆设置内存上限
```
//更改老生代堆内存
--max-old-space-size = 3000 //MB
//更改新生代堆内存
--max-new-space-size = 2000//KB
```

>堆的内存上限在启动时就已经决定，无法动态更改，想要更改，唯一的方法是关闭进程，使用新的配置重新启动。

<!--more-->
## 三、V8垃圾回收机制
>V8将堆内存分类
>>默认情况下，V8为老年代分配的空间，大概是新生代的`40`多倍。新对象都会被分配到新生代中，当新生代空间不足以分配新对象时，将触发新生代的垃圾回收。
1. `新生代` : 未经历过垃圾回收或仅一次的对象
2. `老生代` : 存活时间长的老对象，经历过一次或更多次回收的对象

  

### 新生代的垃圾回收
>`Scavenge` 算法将新生代的总空间一分为二，只使用其中一个，另一个处于闲置，等待垃圾回收时使用。使用中的那块空间称为From，闲置的空间称为To。
![Scavenge算法](/images/javascript/Scavenge算法.png)


### 老生代的垃圾回收
>标记 - 回收

### 增量标记 `Incremental Marking`
>早期V8在垃圾回收阶段，采用全停顿 `(stop the world)`，也就是垃圾回收时程序运行会被暂停。这在JavaScript还仅被用于浏览器端开发时，并没有什么明显的缺点，前端开发使用的内存少，大多数时候仅触发新生代垃圾回收，速度快，卡顿几乎感觉不到。但是对于Node程序，使用内存更多，在老年代垃圾回收时，全停顿很容易带来明显的程序迟滞，标记阶段很容易就会超过100ms，因此V8引入了增量标记，将标记阶段分为若干小步骤，每个步骤控制在5ms内，每运行一段时间标记动作，就让JavaScript程序执行一会儿，如此交替，明显地提高了程序流畅性，一定程度上避免了长时间卡顿。


---
# 内存管理与优化
1. 手动变量销毁
使用var声明的变量，都会成为全局对象的属性，而全局对象不手动置null，则直到程序停止运行才会销毁

2. 闭包
每一个闭包都会引用其外部函数的Context，以此访问需要读取的外部变量。被闭包捕捉，加入Context中的变量，我们称为Context变量，分配在堆。而真正的局部变量（local variable）是 x ，保存在栈，当outer执行完毕后，其信息出栈，变量 x 自然销毁，而Context被闭包引用，如果有任何一个闭包存活，Context都将存活，y 将不会被销毁,
而且应该避免深层闭包嵌套

3. 大内存使用
使用 `stream ` 和 `pipe` 读取大内容，防止占用过多内存
`Buffer` 本身对象保存在堆中，由V8管理，而保存的内容是由C++申请分配的，是保存在堆外的