<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>channel | 薛定谔的Bug</title>
<meta name="keywords" content="">
<meta name="description" content="
CSP(communicating sequential processes) 模型由并发执行实体(进程，线程或协程)，和消息通道组成，实体之间通过消息通道发送消息进行通信。和 Actor 模型不同，CSP 模型关注的是消息发送的载体，即通道，而不是发送消息的执行实体。Go 语言的并发模型参考了 CSP 理论，其中执行实体对应的是 goroutine， 消息通道对应的就是 channel。CSP 模型的核心是：不通过共享内存来达到通讯，而是通过通讯来共享内存。


channel 提供了一种通信机制，通过它，一个 goroutine 可以与另一 goroutine 发送消息。channel 本身还需关联了一个类型，也就是可以发送数据的类型。可以通过 len() 获取通道当前缓冲数量。 cap() 获取通道最大缓冲。
">
<meta name="author" content="Treasure">
<link rel="canonical" href="https://domyson.github.io/2020/01/channel/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://domyson.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://domyson.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://domyson.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://domyson.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://domyson.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="channel" />
<meta property="og:description" content="
CSP(communicating sequential processes) 模型由并发执行实体(进程，线程或协程)，和消息通道组成，实体之间通过消息通道发送消息进行通信。和 Actor 模型不同，CSP 模型关注的是消息发送的载体，即通道，而不是发送消息的执行实体。Go 语言的并发模型参考了 CSP 理论，其中执行实体对应的是 goroutine， 消息通道对应的就是 channel。CSP 模型的核心是：不通过共享内存来达到通讯，而是通过通讯来共享内存。


channel 提供了一种通信机制，通过它，一个 goroutine 可以与另一 goroutine 发送消息。channel 本身还需关联了一个类型，也就是可以发送数据的类型。可以通过 len() 获取通道当前缓冲数量。 cap() 获取通道最大缓冲。
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://domyson.github.io/2020/01/channel/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-01-20T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-01-20T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="channel"/>
<meta name="twitter:description" content="
CSP(communicating sequential processes) 模型由并发执行实体(进程，线程或协程)，和消息通道组成，实体之间通过消息通道发送消息进行通信。和 Actor 模型不同，CSP 模型关注的是消息发送的载体，即通道，而不是发送消息的执行实体。Go 语言的并发模型参考了 CSP 理论，其中执行实体对应的是 goroutine， 消息通道对应的就是 channel。CSP 模型的核心是：不通过共享内存来达到通讯，而是通过通讯来共享内存。


channel 提供了一种通信机制，通过它，一个 goroutine 可以与另一 goroutine 发送消息。channel 本身还需关联了一个类型，也就是可以发送数据的类型。可以通过 len() 获取通道当前缓冲数量。 cap() 获取通道最大缓冲。
"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://domyson.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "channel",
      "item": "https://domyson.github.io/2020/01/channel/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "channel",
  "name": "channel",
  "description": " CSP(communicating sequential processes) 模型由并发执行实体(进程，线程或协程)，和消息通道组成，实体之间通过消息通道发送消息进行通信。和 Actor 模型不同，CSP 模型关注的是消息发送的载体，即通道，而不是发送消息的执行实体。Go 语言的并发模型参考了 CSP 理论，其中执行实体对应的是 goroutine， 消息通道对应的就是 channel。CSP 模型的核心是：不通过共享内存来达到通讯，而是通过通讯来共享内存。\n  channel 提供了一种通信机制，通过它，一个 goroutine 可以与另一 goroutine 发送消息。channel 本身还需关联了一个类型，也就是可以发送数据的类型。可以通过 len() 获取通道当前缓冲数量。 cap() 获取通道最大缓冲。\n",
  "keywords": [
    
  ],
  "articleBody": " CSP(communicating sequential processes) 模型由并发执行实体(进程，线程或协程)，和消息通道组成，实体之间通过消息通道发送消息进行通信。和 Actor 模型不同，CSP 模型关注的是消息发送的载体，即通道，而不是发送消息的执行实体。Go 语言的并发模型参考了 CSP 理论，其中执行实体对应的是 goroutine， 消息通道对应的就是 channel。CSP 模型的核心是：不通过共享内存来达到通讯，而是通过通讯来共享内存。\n  channel 提供了一种通信机制，通过它，一个 goroutine 可以与另一 goroutine 发送消息。channel 本身还需关联了一个类型，也就是可以发送数据的类型。可以通过 len() 获取通道当前缓冲数量。 cap() 获取通道最大缓冲。\n channel 用于在不同的 goroutine 中实现数据传递和共享，是一个FIFO的队列，同样也是一个线程安全的结构。\n  只读：不可写，make(。\n  只写：不可读，make(chan 。\n  双通道：可读可写，make(chan struct{},n)。\n  无缓冲：如果有数据，则读写阻塞，如果无数据，则在写入之前，读阻塞。make(chan struct{})。\n  How to use   如果 channel 未关闭，在读取超时会引发 deadlock 异常。\n  如果 channel 关闭进行写入则会 panic。\n  如果 channel 无数据则会读取到这个值的零值。\n  使用 range 读取，如果管道未关闭触发 deadlock。\n  未初始化的 channel 读会一直阻塞\n   对于未关闭的 channel 也不会 deadlocks，每个 case 都有机会执行，并且不会在关闭的 channel 等待。\n  创建\n 只能通过 make 创建，缓冲只对于数据未填满写，未空读，如果缓冲满了，那么些写入将阻塞，若过缓冲空了，那么读取将阻塞\n //无缓冲，数据类型为int的channel ch0 := make(chan int)  //缓冲，数据类型为int的channel,只要容量大于0即可 ch1 := make(chan int,1)   读取写数据\nch := make(chan int,10)  //通过迭代读取 for x := range ch{  //如果channel关闭，那么直接退出循环不出异常，所以 for-range可以检查channel的状态 }  /* 读取，如果通道关闭则返回channel类型的0值 如果ch没有数据则阻塞 */ x :=  ch  /* 如果ok为false，代表ch关闭 */ y,ok :=  ch   close(channel)\n  关闭一个未初始化(nil) 的 channel 会产生 panic\n  重复关闭同一个 channel 会产生 panic\n  向一个已关闭的 channel 中发送消息会产生 panic\n  从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已读出，则会读到类型的零值。从一个已关闭的 channel 中读取消息永远不会阻塞，并且会返回一个为 false 的 val,ok，可以用它来判断 channel 是否关闭。\n  关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息。\n  对于统一关闭的 Goroutine 建议使用同一个 channel 控制，上述原理。\n    select-case\n//select用于监听 channel 的触发 select{  case  ch1:  //TODO  case  ch2:  //TODO  case ch1  10:  //TODO  default:  //TODO }   select 不会在 nil 上等待。\n  select 可以同时监听多个 channel 的写入或读取。\n  执行 select 时，若只有一个 case 通过(不阻塞)，则执行这个 case 块。\n  若有多个 case 通过，则随机挑选一个 case 执行。\n  若所有 case 均阻塞，且定义了 default 模块，则执行 default 模块。若未定义 default 模块，则 select 语句阻塞，直到有 case 被唤醒。\n  使用 break 会跳出 select 块。\n  select 阻塞会触发 goroutine 调度。\n    单向的channel\n//只写channel 无任何实际意义 ch0 := make(chan  int)  //只读channel 只能做一个初始化的容器 无任何实际意义 ch1 := make( chan int)   其它 Mutex 和 channel 本质都是处理并发竞争问题，但是对于给予特定 Goroutine 的数据，channel 可能更加适合，而对于同一时间任何Goroutine都能访问的数据，Mutex更好,而且Mutex比channel更轻量。\n",
  "wordCount" : "1387",
  "inLanguage": "en",
  "datePublished": "2020-01-20T00:00:00Z",
  "dateModified": "2020-01-20T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Treasure"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://domyson.github.io/2020/01/channel/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "薛定谔的Bug",
    "logo": {
      "@type": "ImageObject",
      "url": "https://domyson.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://domyson.github.io/" accesskey="h" title="薛定谔的Bug (Alt + H)">薛定谔的Bug</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://domyson.github.io/archives/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://domyson.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      channel
    </h1>
    <div class="post-meta"><span title='2020-01-20 00:00:00 +0000 UTC'>January 20, 2020</span>&nbsp;·&nbsp;Treasure

</div>
  </header> 
  <div class="post-content"><blockquote>
<p><code>CSP(communicating sequential processes)</code> 模型由并发执行实体(进程，线程或协程)，和消息通道组成，实体之间通过消息通道发送消息进行通信。和 <code>Actor</code> 模型不同，<code>CSP</code> 模型关注的是消息发送的载体，即通道，而不是发送消息的执行实体。Go 语言的并发模型参考了 CSP 理论，其中执行实体对应的是 <code>goroutine，</code> 消息通道对应的就是 <code>channel</code>。<code>CSP</code> 模型的核心是：不通过共享内存来达到通讯，而是通过通讯来共享内存。</p>
</blockquote>
<blockquote>
<p><code>channel</code> 提供了一种通信机制，通过它，一个 <code>goroutine</code> 可以与另一 <code>goroutine</code> 发送消息。<code>channel</code> 本身还需关联了一个类型，也就是可以发送数据的类型。可以通过 <code>len()</code> 获取通道当前缓冲数量。 <code>cap()</code> 获取通道最大缓冲。</p>
</blockquote>
<p><code>channel</code> 用于在不同的 <code>goroutine</code> 中实现数据传递和共享，是一个FIFO的队列，同样也是一个线程安全的结构。</p>
<ol>
<li>
<p>只读：不可写，<code>make(&lt;-chan struct{},n)</code>。</p>
</li>
<li>
<p>只写：不可读，<code>make(chan &lt;- struct{},n)</code>。</p>
</li>
<li>
<p>双通道：可读可写，<code>make(chan struct{},n)</code>。</p>
</li>
<li>
<p>无缓冲：如果有数据，则读写阻塞，如果无数据，则在写入之前，读阻塞。<code>make(chan struct{})</code>。</p>
</li>
</ol>
<h1 id="how-to-use">How to use<a hidden class="anchor" aria-hidden="true" href="#how-to-use">#</a></h1>
<ol>
<li>
<p>如果 <code>channel</code> 未关闭，在读取超时会引发 <code>deadlock</code> 异常。</p>
</li>
<li>
<p>如果 <code>channel</code> 关闭进行写入则会 <code>panic</code>。</p>
</li>
<li>
<p>如果 <code>channel</code> 无数据则会读取到这个值的零值。</p>
</li>
<li>
<p>使用 <code>range</code> 读取，如果管道未关闭触发 <code>deadlock</code>。</p>
</li>
<li>
<p>未初始化的 <code>channel</code> 读会一直阻塞</p>
</li>
</ol>
<blockquote>
<p>对于未关闭的 <code>channel</code> 也不会 <code>deadlocks</code>，每个 <code>case</code> 都有机会执行，并且不会在关闭的 <code>channel</code> 等待。</p>
</blockquote>
<ol start="5">
<li>
<p>创建</p>
<blockquote>
<p>只能通过 <code>make</code> 创建，缓冲只对于数据未填满写，未空读，如果缓冲满了，那么些写入将阻塞，若过缓冲空了，那么读取将阻塞</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">//无缓冲，数据类型为int的channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ch0</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//缓冲，数据类型为int的channel,只要容量大于0即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">1</span>)
</span></span></code></pre></div></li>
<li>
<p>读取写数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//通过迭代读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果channel关闭，那么直接退出循环不出异常，所以 for-range可以检查channel的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    读取，如果通道关闭则返回channel类型的0值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    如果ch没有数据则阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    如果ok为false，代表ch关闭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span>,<span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
</span></span></code></pre></div></li>
<li>
<p><code>close(channel)</code></p>
<ul>
<li>
<p>关闭一个未初始化(nil) 的 channel 会产生 panic</p>
</li>
<li>
<p>重复关闭同一个 channel 会产生 panic</p>
</li>
<li>
<p>向一个已关闭的 channel 中发送消息会产生 panic</p>
</li>
<li>
<p>从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已读出，则会读到类型的零值。从一个已关闭的 channel 中读取消息<code>永远不会阻塞</code>，并且会返回一个为 false 的 <code>val,ok</code>，可以用它来判断 channel 是否关闭。</p>
</li>
<li>
<p>关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息。</p>
</li>
<li>
<p>对于统一关闭的 <code>Goroutine</code> 建议使用同一个 <code>channel</code> 控制，上述原理。</p>
</li>
</ul>
</li>
<li>
<p><code>select-case</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">//select用于监听 channel 的触发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">select</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch1</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch2</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ch1</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li>
<p><code>select</code> 不会在 <code>nil</code> 上等待。</p>
</li>
<li>
<p><code>select</code> 可以同时监听多个 <code>channel</code> 的写入或读取。</p>
</li>
<li>
<p>执行 <code>select</code> 时，若只有一个 <code>case</code> 通过(不阻塞)，则执行这个 <code>case</code> 块。</p>
</li>
<li>
<p>若有多个 <code>case</code> 通过，则随机挑选一个 <code>case</code> 执行。</p>
</li>
<li>
<p>若所有 <code>case</code> 均阻塞，且定义了 <code>default</code> 模块，则执行 <code>default</code> 模块。若未定义 <code>default</code> 模块，则 <code>select</code> 语句阻塞，直到有 <code>case</code> 被唤醒。</p>
</li>
<li>
<p>使用 <code>break</code> 会跳出 <code>select</code> 块。</p>
</li>
<li>
<p><code>select</code> 阻塞会触发 <code>goroutine</code> 调度。</p>
</li>
</ul>
</li>
<li>
<p>单向的<code>channel</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">//只写channel 无任何实际意义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ch0</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//只读channel 只能做一个初始化的容器 无任何实际意义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ch1</span> <span style="color:#f92672">:=</span> make(<span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span></code></pre></div></li>
</ol>
<h1 id="其它">其它<a hidden class="anchor" aria-hidden="true" href="#其它">#</a></h1>
<p><code>Mutex</code> 和 <code>channel</code> 本质都是处理并发竞争问题，但是对于给予特定 <code>Goroutine</code> 的数据，<code>channel</code> 可能更加适合，而对于同一时间任何<code>Goroutine</code>都能访问的数据，<code>Mutex</code>更好,而且<code>Mutex</code>比<code>channel</code>更轻量。</p>

  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://domyson.github.io/">薛定谔的Bug</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
