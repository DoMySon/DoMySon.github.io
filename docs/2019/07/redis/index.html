<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Redis | 薛定谔的Bug</title>
<meta name="keywords" content="database">
<meta name="description" content="Redis是一种基于内存的数据库，并且提供一定的持久化功能。它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。">
<meta name="author" content="Treasure">
<link rel="canonical" href="https://domyson.github.io/2019/07/redis/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://domyson.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://domyson.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://domyson.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://domyson.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://domyson.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Redis" />
<meta property="og:description" content="Redis是一种基于内存的数据库，并且提供一定的持久化功能。它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://domyson.github.io/2019/07/redis/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-07-24T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2019-07-24T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis"/>
<meta name="twitter:description" content="Redis是一种基于内存的数据库，并且提供一定的持久化功能。它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://domyson.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Redis",
      "item": "https://domyson.github.io/2019/07/redis/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis",
  "name": "Redis",
  "description": "Redis是一种基于内存的数据库，并且提供一定的持久化功能。它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。",
  "keywords": [
    "database"
  ],
  "articleBody": "Liunx安装 基本数据结构    类型 介绍     string 键值对   has hash表   list 字符串列表   set 无重复列表   sorted set 有序无重复列表   subscribe/publish 发布订阅模式     Redis命令\n  Redis下载\n 持久化 AOF   AOF文件中实际存储的是 Redis 协议下的命令记录,把每一次写操作以追加的形式记录在其中以文件的形式刷到磁盘里.\n  fsync 策略\n  无 fsync : 数据容易丢失\n  每秒 fsync : 默认策略，性能正常，由后台线程执行，最多丢失1秒的数据，但文件大小随着时间线性增长，若用来恢复数据会非常缓慢。\n  每次写 fsync : 牺牲大部分性能，文件也大，但基本不会丢失数据\n    RDB   一种快照机制，每个一段时间会对内存数据进行一次快照，保存在 rdb 文件中\n  SAVE 和 BGSAVE 命令分别是同步保存和 fork 子进程保存\n  RDB 文件非常紧凑，它保存了 Redis 某个时间点上的数据集。RDB 恢复大数据集时速度要比 AOF 快。但是 RDB 不适合那些对时效性要求很高的业务，因为它只保存了快照，在进行恢复时会导致一些时间内的数据丢失。\n  如果数据量很大的话 rdb 它要保存一个完整的数据集 是一个大的工作 如果时间间隔设置的太短，那么严重影响redis的性能 但是按照常规设置的话 如5分钟一次 那么如果宕机或者重启 就会基于上次做rdb的时间，而丢失分钟级的数据\n  管道技术   Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。\n  管道技术最显著的优势是提高了 redis 服务的性能。\n  事务   批量操作在发送 EXEC 命令前被放入队列缓存。\n  收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。\n  在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n  一个事务从开始到执行会经历以下三个阶段：\n 开始事务。 命令入队。 执行事务。     +命令 描述     DISCARD 取消事务，放弃执行事务块内的所有命令。   EXEC 执行所有事务块内的命令。   MULTI 标记一个事务块的开始。   UNWATCH 取消 WATCH 命令对所有 key 的监视。    WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\n集群 概念   Redis集群中的节点都需要打开两个TCP连接。一个连接用于正常的给Client提供服务，比如6379，还有一个额外的端口（通过在这个端口号上加10000）作为数据端口，比如16379。第二个端口用于集群总线，这是一个用二进制协议的点对点通信信道。这个集群总线（Cluster bus）用于节点的失败侦测、配置更新、故障转移授权，等等。客户端从来都不应该尝试和这些集群总线端口通信，它们只应该和正常的Redis命令端口进行通信。注意，确保在你的防火墙中开放着两个端口，否则，Redis集群节点之间将无法通信。\n  所有 Redis 节点彼此相连（内部 PING-PONG）机制\n  节点 Fail 至少通过集群半数以上的节点检测失效才生效\n  客户端只需要连接其中一个节点即可\n  Redis-Cluster 负责把物理节点映射到 [0-16383]slot 上, cluster 负责维护 node  slot  value\n  Redis 集群分片   Redis 集群不同一致性哈希，它用一种不同的分片形式，在这种形式中，每个key都是一个概念性（hash slot）的一部分。 Redis集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点\n  允许添加和删除集群节点。如增加一个新的节点D，那么需要从A、B、C节点上删除一些hash slot给到D。同样地，如果从集群中删除节点A，那么会将A上面的hash slot 移动到B和C，当节点A上是空的时候就可以将其从集群中完全删除。\n  Redis 集群主从模式   投票过程需要整个集群的 Master 节点参与，当其中存在与集群半数以上的 Master 节点通讯失败，则剔除此 Master\n  Master-Slave 模式，当集群中有 Master 节点失败的话，则其 Slave 节点将有一个提升为新的 Master 节点。\n  如果集群任意 Master 挂掉,若其没有 Slave .集群进入 fail 状态,也可以理解成集群的slot映射 [0-16383] 不完整时进入fail状态.\n  如果集群超过半数以上 master 挂掉，无论是否有 slave ，集群进入 fail 状态.\n  #主从模式配置\rbind 0.0.0.0\rport 6379\rlogfile \"6379.log\"\rdbfilename \"dump-6379.rdb\"\rdaemonize yes\rrdbcompression yes\r#slaveof 192.168.81.135 6379 这个配置应用的是slave节点，指定的是 master 节点\r# slave-read-only yes 默认 slave 节点只提供读取，可以通过设置 Reids 集群一致性  Redis 集群不能保证强一致性  集群搭建  修改配置文件 # redis.conf文件\r#客户端端口\rport 7000\r#pid文件\rpidfile /var/run/redis_6379.pid\r# 启用集群\rcluster-enable yes\r# 由redis集群自动生成\rcluster-config-file nodes.conf\r# 集群ping-pong超时时间 ms\rcluster-node-timeout 5000\r#是否启用aof\rappendonly on   名词解释 这几种情况都是从缓存没有获取到数据，大量的并发请求到了数据源，给数据源造成很大压力，从而可能引发问题\n  缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。\n  缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。\n  缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。\n  优化   使用短的key\n  避免使用 keys *：这个命令是阻塞的，使用 SCAN 代替\n  设置 key 的过期时间\n   线上解决方案   缓存穿透 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。\n  缓存击穿 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。\n  缓存雪崩 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期\n ",
  "wordCount" : "2557",
  "inLanguage": "en",
  "datePublished": "2019-07-24T00:00:00Z",
  "dateModified": "2019-07-24T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Treasure"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://domyson.github.io/2019/07/redis/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "薛定谔的Bug",
    "logo": {
      "@type": "ImageObject",
      "url": "https://domyson.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://domyson.github.io/" accesskey="h" title="薛定谔的Bug (Alt + H)">薛定谔的Bug</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://domyson.github.io/archives/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://domyson.github.io/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Redis
    </h1>
    <div class="post-description">
      Redis是一种基于内存的数据库，并且提供一定的持久化功能。它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。
    </div>
    <div class="post-meta"><span title='2019-07-24 00:00:00 +0000 UTC'>July 24, 2019</span>&nbsp;·&nbsp;Treasure

</div>
  </header> 
  <div class="post-content"><h1 id="liunx安装">Liunx安装<a hidden class="anchor" aria-hidden="true" href="#liunx安装">#</a></h1>
<h1 id="基本数据结构">基本数据结构<a hidden class="anchor" aria-hidden="true" href="#基本数据结构">#</a></h1>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>string</code></td>
<td style="text-align:center">键值对</td>
</tr>
<tr>
<td style="text-align:center"><code>has</code></td>
<td style="text-align:center">hash表</td>
</tr>
<tr>
<td style="text-align:center"><code>list</code></td>
<td style="text-align:center">字符串列表</td>
</tr>
<tr>
<td style="text-align:center"><code>set</code></td>
<td style="text-align:center">无重复列表</td>
</tr>
<tr>
<td style="text-align:center"><code>sorted set</code></td>
<td style="text-align:center">有序无重复列表</td>
</tr>
<tr>
<td style="text-align:center"><code>subscribe/publish</code></td>
<td style="text-align:center">发布订阅模式</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="http://doc.redisfans.com/index.html">Redis命令</a></p>
</blockquote>
<blockquote>
<p><a href="https://redis.io/download">Redis下载</a></p>
</blockquote>
<h1 id="持久化">持久化<a hidden class="anchor" aria-hidden="true" href="#持久化">#</a></h1>
<h2 id="aof">AOF<a hidden class="anchor" aria-hidden="true" href="#aof">#</a></h2>
<ul>
<li>
<p>AOF文件中实际存储的是 Redis 协议下的命令记录,把每一次写操作以追加的形式记录在其中以文件的形式刷到磁盘里.</p>
</li>
<li>
<p><code>fsync</code> 策略</p>
<ol>
<li>
<p>无 <code>fsync</code> : 数据容易丢失</p>
</li>
<li>
<p>每秒 <code>fsync</code> : 默认策略，性能正常，由后台线程执行，最多丢失1秒的数据，但文件大小随着时间线性增长，若用来恢复数据会非常缓慢。</p>
</li>
<li>
<p>每次写 <code>fsync</code> : 牺牲大部分性能，文件也大，但基本不会丢失数据</p>
</li>
</ol>
</li>
</ul>
<h2 id="rdb">RDB<a hidden class="anchor" aria-hidden="true" href="#rdb">#</a></h2>
<ul>
<li>
<p>一种快照机制，每个一段时间会对内存数据进行一次快照，保存在 <code>rdb</code> 文件中</p>
</li>
<li>
<p><code>SAVE</code> 和 <code>BGSAVE</code> 命令分别是同步保存和 fork 子进程保存</p>
</li>
<li>
<p>RDB 文件非常紧凑，它保存了 Redis 某个时间点上的数据集。RDB 恢复大数据集时速度要比 AOF 快。但是 RDB 不适合那些对时效性要求很高的业务，因为它只保存了快照，在进行恢复时会导致一些时间内的数据丢失。</p>
</li>
<li>
<p>如果数据量很大的话 <code>rdb</code> 它要保存一个完整的数据集 是一个大的工作 如果时间间隔设置的太短，那么严重影响redis的性能 但是按照常规设置的话 如5分钟一次 那么如果宕机或者重启 就会基于上次做rdb的时间，而丢失分钟级的数据</p>
</li>
</ul>
<h1 id="管道技术">管道技术<a hidden class="anchor" aria-hidden="true" href="#管道技术">#</a></h1>
<ul>
<li>
<p>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p>
</li>
<li>
<p>管道技术最显著的优势是提高了 redis 服务的性能。</p>
</li>
</ul>
<h1 id="事务">事务<a hidden class="anchor" aria-hidden="true" href="#事务">#</a></h1>
<ul>
<li>
<p>批量操作在发送 EXEC 命令前被放入队列缓存。</p>
</li>
<li>
<p>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</p>
</li>
<li>
<p>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
</li>
</ul>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">+命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DISCARD</code></td>
<td style="text-align:center">取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td style="text-align:center"><code>EXEC</code></td>
<td style="text-align:center">执行所有事务块内的命令。</td>
</tr>
<tr>
<td style="text-align:center"><code>MULTI</code></td>
<td style="text-align:center">标记一个事务块的开始。</td>
</tr>
<tr>
<td style="text-align:center"><code>UNWATCH</code></td>
<td style="text-align:center">取消 WATCH 命令对所有 key 的监视。</td>
</tr>
</tbody>
</table>
<p><code>WATCH key [key ...]</code> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<h1 id="集群">集群<a hidden class="anchor" aria-hidden="true" href="#集群">#</a></h1>
<h2 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h2>
<ol>
<li>
<p>Redis集群中的节点都需要打开两个TCP连接。一个连接用于正常的给Client提供服务，比如6379，还有一个额外的端口（通过在这个端口号上加10000）作为数据端口，比如16379。第二个端口用于集群总线，这是一个用二进制协议的点对点通信信道。这个集群总线（Cluster bus）用于节点的失败侦测、配置更新、故障转移授权，等等。客户端从来都不应该尝试和这些集群总线端口通信，它们只应该和正常的Redis命令端口进行通信。注意，确保在你的防火墙中开放着两个端口，否则，Redis集群节点之间将无法通信。</p>
</li>
<li>
<p>所有 <code>Redis</code> 节点彼此相连（内部 PING-PONG）机制</p>
</li>
<li>
<p>节点 <code>Fail</code> 至少通过集群半数以上的节点检测失效才生效</p>
</li>
<li>
<p>客户端只需要连接其中一个节点即可</p>
</li>
<li>
<p><code>Redis-Cluster</code> 负责把物理节点映射到 <code>[0-16383]slot</code> 上, <code>cluster</code> 负责维护 <code>node &lt;-&gt; slot &lt;-&gt; value</code></p>
</li>
</ol>
<h2 id="redis-集群分片">Redis 集群分片<a hidden class="anchor" aria-hidden="true" href="#redis-集群分片">#</a></h2>
<ul>
<li>
<p><code>Redis</code> 集群不同一致性哈希，它用一种不同的分片形式，在这种形式中，每个key都是一个概念性（hash slot）的一部分。 Redis集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</p>
</li>
<li>
<p>允许添加和删除集群节点。如增加一个新的节点D，那么需要从A、B、C节点上删除一些hash slot给到D。同样地，如果从集群中删除节点A，那么会将A上面的hash slot 移动到B和C，当节点A上是空的时候就可以将其从集群中完全删除。</p>
</li>
</ul>
<h2 id="redis-集群主从模式">Redis 集群主从模式<a hidden class="anchor" aria-hidden="true" href="#redis-集群主从模式">#</a></h2>
<ul>
<li>
<p>投票过程需要整个集群的 <code>Master</code> 节点参与，当其中存在与集群半数以上的 <code>Master</code> 节点通讯失败，则剔除此 <code>Master</code></p>
</li>
<li>
<p><code>Master-Slave</code> 模式，当集群中有 <code>Master</code> 节点失败的话，则其 <code>Slave</code> 节点将有一个提升为新的 <code>Master</code> 节点。</p>
</li>
<li>
<p>如果集群任意 <code>Master</code> 挂掉,若其没有 <code>Slave</code> .集群进入 <code>fail</code> 状态,也可以理解成集群的slot映射 <code>[0-16383] </code>不完整时进入fail状态.</p>
</li>
<li>
<p>如果集群超过半数以上 <code>master </code>挂掉，无论是否有 <code>slave</code> ，集群进入 <code>fail</code> 状态.</p>
</li>
</ul>
<pre tabindex="0"><code class="language-redis" data-lang="redis">#主从模式配置

bind 0.0.0.0

port 6379

logfile &#34;6379.log&#34;

dbfilename &#34;dump-6379.rdb&#34;

daemonize yes

rdbcompression yes

#slaveof 192.168.81.135 6379 这个配置应用的是slave节点，指定的是 master 节点

# slave-read-only yes 默认 slave 节点只提供读取，可以通过设置
</code></pre><h2 id="reids-集群一致性">Reids 集群一致性<a hidden class="anchor" aria-hidden="true" href="#reids-集群一致性">#</a></h2>
<ul>
<li><code>Redis</code> 集群不能保证强一致性</li>
</ul>
<h2 id="集群搭建">集群搭建<a hidden class="anchor" aria-hidden="true" href="#集群搭建">#</a></h2>
<ul>
<li>修改配置文件
<pre tabindex="0"><code class="language-redis" data-lang="redis"># redis.conf文件

#客户端端口
port 7000

#pid文件
pidfile /var/run/redis_6379.pid

# 启用集群
cluster-enable yes

# 由redis集群自动生成
cluster-config-file nodes.conf

# 集群ping-pong超时时间 ms
cluster-node-timeout 5000

#是否启用aof
appendonly on
</code></pre></li>
</ul>
<h1 id="名词解释">名词解释<a hidden class="anchor" aria-hidden="true" href="#名词解释">#</a></h1>
<p>这几种情况都是从缓存没有获取到数据，大量的并发请求到了数据源，给数据源造成很大压力，从而可能引发问题</p>
<ul>
<li>
<p>缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
</li>
<li>
<p>缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
</li>
<li>
<p>缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p>
</li>
</ul>
<h1 id="优化">优化<a hidden class="anchor" aria-hidden="true" href="#优化">#</a></h1>
<ul>
<li>
<p>使用短的key</p>
</li>
<li>
<p>避免使用 <code>keys *</code>：这个命令是阻塞的，使用 <code>SCAN</code> 代替</p>
</li>
<li>
<p>设置 <code>key</code> 的过期时间</p>
</li>
<li></li>
</ul>
<h1 id="线上解决方案">线上解决方案<a hidden class="anchor" aria-hidden="true" href="#线上解决方案">#</a></h1>
<ul>
<li>
<p>缓存穿透
采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。
对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
</li>
<li>
<p>缓存击穿
利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</p>
</li>
<li>
<p>缓存雪崩
在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
</li>
</ul>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://domyson.github.io/tags/database/">database</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://domyson.github.io/">薛定谔的Bug</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
